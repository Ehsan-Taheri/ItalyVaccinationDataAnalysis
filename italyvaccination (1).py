# -*- coding: utf-8 -*-
"""italyvaccination.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/gist/leanerr/1702cf51c7413ad9cb577eacca7da34e/italyvaccination.ipynb
"""

import numpy as np
import pandas as pd

# Specify the path to your CSV file
csv_file_path = '/content/italian_vaccination.csv'

# Read CSV using pandas
df = pd.read_csv(csv_file_path)

# Display the pandas DataFrame
print("DataFrame from pandas:")
print(df)

# Access data using NumPy (if needed)
numpy_array = df.to_numpy()
print("\nNumPy array from pandas DataFrame:")
print(numpy_array)

df.head(1000)

df.tail()

df.shape

import missingno as msno
import matplotlib.pyplot as plt

# Check for missing values
print("\nMissing values in the dataset:")
print(df.isnull().sum())

# Visualize missing values with a matrix plot
msno.matrix(df)
plt.title("Missing Values Matrix")
plt.show()

df.info()

# Check for negative values
print("\nColumns with negative values:")
for column in df.columns:
    # Check if the column contains numeric values
    if pd.api.types.is_numeric_dtype(df[column]):
        negative_values_count = (df[column] < 0).sum()
        if negative_values_count > 0:
            print(f"{column}: {negative_values_count} negative values")

# Visualize negative values with a histogram
numeric_df = df.select_dtypes(include=['number'])
numeric_df[numeric_df < 0].hist(bins=20, figsize=(10, 6))
plt.suptitle("Histogram of Negative Values")
plt.show()

df.nunique()

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Load the dataset
df = pd.read_csv('italian_vaccination.csv')

numerical_features = ['first_dose', 'second_dose',  'males', 'females','previous_infection', 'additional_booster_dose', 'second_booster', 'db3']


# Explore correlations between numerical features
correlation_matrix = df[numerical_features].corr()
plt.figure(figsize=(12, 10))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Correlation Matrix')
plt.show()

!pip install plotly

df.region.value_counts()

df.supplier.value_counts()

import seaborn as sns
import matplotlib.pyplot as plt

df.females.sum(),df.males.sum()

total_vaccinations=df.males.sum()+df.females.sum()
total_vaccinations

print("Number of Vaccination for Gender")
tot=np.array([df.males.sum(),df.females.sum()])
tot=pd.DataFrame(tot,index=["Males","Females"])
tot.columns=["Total"]
tot.gender=["Males","Females"]
tot

import matplotlib.pyplot as plt
import pandas as pd

# Assuming 'df' contains the dataset with columns 'males' and 'females'
# If not, replace these columns with the correct ones from your DataFrame

# Calculate the total vaccinations for each gender
total_male = df['males'].sum()
total_female = df['females'].sum()

# Plotting using Matplotlib
plt.figure(figsize=(8, 6))
plt.bar(['Males', 'Females'], [total_male, total_female], color=['blue', 'red'])
plt.title('Total Number of Vaccinations by Gender')
plt.xlabel('Gender')
plt.ylabel('Total')
plt.show()

"""

Of course we have to weight this data with the real values for the distribution of the population in Italy. We found in this site this values of 28,749,359 for Male population and 30,101,358 for Female population who is registered at the moment in Italy.

You can find this data at this site: 28864088 https://www.statista.com/statistics/786485/population-by-gender-in-italy/
"""

tot["Registered"]=[28749359,30101358]
tot["Prop"]=tot.Total/tot.Registered
tot

import pandas as pd

# Assuming df is your original DataFrame
# Replace this with your actual DataFrame
# df = ...

# Group by "administration_date" and "region_name," and sum the "males" and "females" columns
RegionOverTimeMaleFemale = pd.DataFrame(df.groupby(["administration_date", "region_name"])[["males", "females"]].sum().sort_values(by="males", ascending=False))
RegionOverTimeMaleFemale.to_csv('RegionOverTimeMaleFemale.csv', index=True)
# Print the result DataFrame
print("Number of Vaccination for Region on male and female population:")
print(RegionOverTimeMaleFemale)

print("Number of Vaccination for Region on male population")
RegionAllTimeMaleFemale = pd.DataFrame(df.groupby("region_name")[["males", "females"]].sum().sort_values(by="males", ascending=False))
RegionAllTimeMaleFemale.to_csv('RegionAllTimeMaleFemale.csv', index=True)
RegionAllTimeMaleFemale

import pandas as pd
import matplotlib.pyplot as plt
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# RegionAllTimeMaleFemale = ...

# Convert the Matplotlib plot to Plotly
fig = make_subplots(rows=1, cols=1)

# Add traces for males and females
fig.add_trace(go.Bar(x=RegionAllTimeMaleFemale['males'], y=RegionAllTimeMaleFemale.index, orientation='h', name='Males'))
fig.add_trace(go.Bar(x=RegionAllTimeMaleFemale['females'], y=RegionAllTimeMaleFemale.index, orientation='h', name='Females'))

# Update layout for better presentation
fig.update_layout(title_text='Number of Vaccinations by Region and Gender',
                  xaxis_title='Count',
                  yaxis_title='Region Name',
                  barmode='stack')

# Show the plot
fig.show()

DosesOverTime_df = df.groupby("administration_date")['first_dose', 'second_dose', 'previous_infection', 'additional_booster_dose', 'second_booster', 'db3'].sum()

# Save the result as a new CSV file
DosesOverTime_df.to_csv('DosesOverTime_df.csv', index=True)

DosesOverTime_df

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# Assuming you have a DataFrame 'DosesOverTime_df'
# DosesOverTime_df = ...

# Define a custom color palette with bold colors
custom_palette = ["#3498db", "#2ecc71", "#e74c3c", "#f39c12", "#9b59b6", "#34495e"]

# Convert the Matplotlib/Seaborn plot to Plotly
fig = make_subplots(rows=1, cols=1)

# Iterate over the columns and add traces
for column in DosesOverTime_df.columns:
    fig.add_trace(go.Scatter(x=DosesOverTime_df.index, y=DosesOverTime_df[column], mode='lines', name=column, line=dict(width=2.5)))

# Update layout for better presentation
fig.update_layout(title_text='Number of Doses Administered Over Time',
                  xaxis_title='Administration Date',
                  yaxis_title='Cumulative Count',
                  legend_title='Dose Type')

# Show the plot
fig.show()

df.groupby("administration_date")['males', 'females'].sum()

df

df["dailytotal"]=df.males+df.females
df.head()

dictionary={"males":df.groupby("administration_date")["males"].sum(),"females":df.groupby("administration_date")["females"].sum()}
daily_gender=pd.DataFrame(dictionary)
daily_gender["Total"]=daily_gender.males+daily_gender.females

daily_gender.to_csv('daily_genderTotal.csv', index=True)
daily_gender

daily_gender.to_csv("dailyTotalMaleFemale.csv")

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# Assuming you have a DataFrame 'daily_gender'
# daily_gender = ...

# Define a custom color palette with bold colors
custom_palette = ["#3498db", "#2ecc71", "#e74c3c", "#f39c12"]

# Convert the Matplotlib/Seaborn plot to Plotly
fig = make_subplots(rows=1, cols=1)

# Iterate over the columns and add traces
for column in daily_gender.columns:
    fig.add_trace(go.Scatter(x=daily_gender.index, y=daily_gender[column], mode='lines', name=column, line=dict(width=2.5)))

# Update layout for better presentation
fig.update_layout(title_text='Number of Vaccinations by Gender Over Time',
                  xaxis_title='Administration Date',
                  yaxis_title='Cumulative Count',
                  legend_title='Gender')

# Show the plot
fig.show()

df.age_range

print("Number of Vaccination for Age in class for the male population")
df.groupby("age_range")["males"].sum().sort_values(ascending = False)

import pandas as pd
import matplotlib.pyplot as plt

# Assuming you have a DataFrame 'MaleVaccinationByAge'
# MaleVaccinationByAge = ...
MaleVaccinationByAge = df.groupby("age_range")["males"].sum().sort_values(ascending=False).reset_index()

# Plotting without interactive features
plt.figure(figsize=(12, 8))
plt.bar(MaleVaccinationByAge['age_range'], MaleVaccinationByAge['males'], color='skyblue')
plt.title('Number of Vaccinations for Each Age Range in the Male Population')
plt.xlabel('Age Range')
plt.ylabel('Number of Vaccinations')
plt.show()

import pandas as pd
import matplotlib.pyplot as plt

# Assuming you have a DataFrame 'feMaleVaccinationByAge'
# feMaleVaccinationByAge = ...
femaleVaccinationByAge = df.groupby("age_range")["females"].sum().sort_values(ascending=False).reset_index()

# Plotting without interactive features
plt.figure(figsize=(12, 8))
plt.bar(femaleVaccinationByAge['age_range'], femaleVaccinationByAge['females'], color='red')
plt.title('Number of Vaccinations for Each Age Range in the female Population')
plt.xlabel('Age Range')
plt.ylabel('Number of Vaccinations')
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Assuming you have a DataFrame 'df'
# df = ...

# Group by "age_range" and sum the doses for males, females, and total
VaccinationByAge = df.groupby("age_range")[["males", "females"]].sum().sort_values(by="males", ascending=False)

# Set Seaborn's "deep" color palette for distinct colors
sns.set_palette("deep")

# Plotting
plt.figure(figsize=(12, 8))
sns.barplot(x=VaccinationByAge.index, y=VaccinationByAge["males"], color="skyblue", label="Males")
sns.barplot(x=VaccinationByAge.index, y=VaccinationByAge["females"], color="red", label="Females")
plt.title('Number of Vaccinations for Each Age Range')
plt.xlabel('Age Range')
plt.ylabel('Count')
plt.legend()
plt.show()

print(((df.groupby("age_range")["dailytotal"].sum().sort_values()/total_vaccinations)*100).round(2))

male=pd.DataFrame(df.groupby("supplier")["males"].sum().sort_values(ascending = False)/df.males.sum())
female=pd.DataFrame(df.groupby("supplier")["females"].sum().sort_values(ascending = False)/df.females.sum())

supplier_tot=pd.DataFrame(df.groupby("supplier").sum())
supplier_tot.to_csv('supplier_total.csv', index=True)

supplier_tot

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns


# Add 'males' and 'females' for each record and create a new column 'total'
supplier_tot['total'] = supplier_tot['males'] + supplier_tot['females']
supplier_tot.to_csv('supplier_total.csv', index=True)

# Display the updated DataFrame
supplier_tot

import pandas as pd
import plotly.express as px

# Assuming you have a DataFrame 'supplier_tot'
# supplier_tot = ...

# Group by "supplier" and sum the doses for males, females, and total
SupplierVaccination = supplier_tot.groupby("supplier")[["males", "females"]].sum().reset_index()

# Create an interactive stacked bar plot using Plotly Express
fig = px.bar(SupplierVaccination, x='supplier', y=['males', 'females'],
             labels={'value': 'Count', 'variable': 'Gender'},
             color_discrete_sequence=['#3498db', '#e74c3c'],
             title='Vaccination Count by Supplier')

# Show the plot
fig.show()

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# Assuming you have a DataFrame 'supplier_tot'
# supplier_tot = ...

# Group by "supplier" and sum the doses for males, females, and total
SupplierVaccination = supplier_tot.groupby("supplier")[["males", "females"]].sum()

# Set a custom color palette for distinct colors
custom_palette = sns.color_palette("husl", 3)
sns.set_palette(custom_palette)

# Convert the Matplotlib/Seaborn plot to Plotly
fig = make_subplots(rows=1, cols=1)

# Iterate over the columns and add traces
for gender in SupplierVaccination.columns:
    fig.add_trace(go.Bar(x=SupplierVaccination.index, y=SupplierVaccination[gender], name=gender))

# Update layout for better presentation
fig.update_layout(title_text='Vaccination Count by Supplier (log scale)',
                  xaxis_title='Supplier',
                  yaxis_title='Count (log scale)',
                  barmode='stack')

# Set y-axis to log scale
fig.update_layout(yaxis_type='log')

# Show the plot
fig.show()

massi=male
massi["gender"]="male"
massi.columns=["tot","gender"]
massi

female["gender"]="female"
female.columns=["tot","gender"]
female

#male.index.sort_values()
supp_man=pd.Series(df.groupby("supplier")["males"].sum())
supp_women=pd.Series(df.groupby("supplier")["females"].sum())
supp_women
supplier_gender={"man":supp_man,"woman":supp_women}
pd.DataFrame(supplier_gender,index=male.index.sort_values())

massi.tot=df.groupby("supplier")["males"].sum().sort_values(ascending = False)
female.tot=df.groupby("supplier")["females"].sum().sort_values(ascending = False)
genderdf=[male,female]
genderdf=pd.concat(genderdf)
genderdf["supplier"]=genderdf.index
genderdf

df["dailytotal"]=df.males+df.females

reg_name=pd.DataFrame(df.groupby("region_name")[['dailytotal','first_dose', 'second_dose', 'previous_infection', 'additional_booster_dose', 'second_booster', 'db3',"males","females"]].sum())
reg_name.to_csv("RegionsDosesTotal.csv")

#reg_name["pop_resid"]=regions["pop_resid"]
#reg_name["propTV"]=reg_name["TotVaccine"]/reg_name["pop_resid"]
reg_name1=reg_name.drop(index=("Provincia Autonoma Bolzano / Bozen"))
reg_name1=reg_name1.drop(index=("Provincia Autonoma Trento"))
reg_name

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# Assuming you have a DataFrame 'df'
# df = ...

# Add a column for daily total
df["dailytotal"] = df["males"] + df["females"]

# Group by "supplier" and sum the doses for each category
SupplierDoses = df.groupby("supplier")[['first_dose', 'second_dose', 'previous_infection', 'additional_booster_dose', 'second_booster', 'db3']].sum()

# Set Seaborn's "deep" color palette for distinct colors
sns.set_palette("deep")

# Convert the Matplotlib/Seaborn plot to Plotly
fig = make_subplots(rows=1, cols=1)

# Iterate over the columns and add traces
for dose_type in SupplierDoses.columns:
    fig.add_trace(go.Bar(x=SupplierDoses.index, y=SupplierDoses[dose_type], name=dose_type))

# Update layout for better presentation
fig.update_layout(title_text='Number of Doses by Supplier',
                  xaxis_title='Supplier',
                  yaxis_title='Count',
                  barmode='stack')

# Show the plot
fig.show()

import pandas as pd
import plotly.express as px

# Assuming you have a DataFrame 'df'
# df = ...

# Add a column for daily total
df["dailytotal"] = df["males"] + df["females"]

# Group by "supplier" and sum the doses for each category
SupplierDoses = df.groupby("supplier")[['first_dose', 'second_dose', 'previous_infection', 'additional_booster_dose', 'second_booster', 'db3']].sum()

# Reset index to convert the grouped data back to a DataFrame
SupplierDoses.reset_index(inplace=True)

# Melt the DataFrame for Plotly Express compatibility
SupplierDoses_melted = pd.melt(SupplierDoses, id_vars=['supplier'], var_name='Dose Type', value_name='Count')

# Create an interactive bar plot using Plotly Express
fig = px.bar(SupplierDoses_melted, x='supplier', y='Count', color='Dose Type',
             labels={'Count': 'Number of Doses (log scale)'},
             title='Number of Doses by Supplier (log scale)',
             log_y=True)  # Set log scale on the y-axis

# Show the plot
fig.show()

df.head()

#Not WORKING!!!!!!!!!!!!!!!!!!!!!!!

import pandas as pd
import plotly.express as px

# Assuming you have a DataFrame 'df' with columns 'region_name', 'first_dose', 'second_dose', 'previous_infection', 'additional_booster_dose', 'second_booster', 'db3'
# df = ...

# Sum the doses for each region
df_summed = df.groupby('region_name').agg({
    'first_dose': 'sum',
    'second_dose': 'sum',
    'previous_infection': 'sum',
    'additional_booster_dose': 'sum',
    'second_booster': 'sum',
    'db3': 'sum'
}).reset_index()

# Melt the DataFrame to create a long-format for Plotly Express
df_melted = pd.melt(df_summed, id_vars=['region_name'], value_vars=['first_dose', 'second_dose', 'previous_infection', 'additional_booster_dose', 'second_booster', 'db3'],
                    var_name='Dose Type', value_name='Count')

# Create an interactive horizontal bar plot using Plotly Express
fig = px.bar(df_melted, x='Count', y='region_name', color='Dose Type',
             labels={'Count': 'Count', 'Dose Type': 'Dose Type'},
             title='Distribution of Vaccination Doses by Region',
             orientation='h', barmode='stack')  # Set orientation='h' for horizontal and barmode='stack' for stacked bars

# Show the plot
fig.show()

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Assuming you have a DataFrame 'df' with columns 'region_name', 'first_dose', 'second_dose', 'dailytotal', etc.
# df = ...

# Get the top 4 regions based on 'dailytotal'
top_regions = df.groupby('region_name')['dailytotal'].sum().sort_values(ascending=False).head(4).index

# Filter DataFrame for the top 4 regions
df_top_regions = df[df['region_name'].isin(top_regions)]

# Melt the DataFrame for Seaborn compatibility
df_melted = pd.melt(df_top_regions, id_vars=['region_name'], value_vars=['first_dose', 'second_dose', 'previous_infection', 'additional_booster_dose', 'second_booster', 'db3'],
                    var_name='Dose Type', value_name='Count')

# Set Seaborn's "deep" color palette for distinct colors
sns.set_palette("deep")

# Plotting
plt.figure(figsize=(12, 8))
sns.barplot(x='region_name', y='Count', hue='Dose Type', data=df_melted, ci=None)  # Remove confidence intervals
plt.title('Distribution of Vaccination Doses by Top 4 Regions (Based on dailytotal)')
plt.xlabel('Region Name')
plt.ylabel('Count')
plt.legend(title='Dose Type', bbox_to_anchor=(1, 1), loc='upper left')
plt.show()

# Not Working!!!!!!!!!!!!!!!!

import pandas as pd
import plotly.express as px

# Assuming you have a DataFrame 'df' with columns 'region_name' and 'supplier'
# df = ...

# Count the occurrences of each supplier in each region
supplier_region_counts = df.groupby(['region_name', 'supplier']).size().reset_index(name='Count')

# Create an interactive horizontal bar plot using Plotly Express
fig = px.bar(supplier_region_counts, x='Count', y='region_name', color='supplier',
             labels={'Count': 'Occurrences'},
             title='Distribution of Suppliers by Region',
             orientation='h')  # Set orientation='h' for horizontal

# Show the plot
fig.show()

import pandas as pd
import plotly.express as px

# Assuming you have a DataFrame 'df' with columns 'region_name', 'supplier', and 'dailytotal'
# df = ...

# Sum the 'dailytotal' for each supplier in each region
supplier_region_weighted_counts = df.groupby(['region_name', 'supplier'])['dailytotal'].sum().reset_index(name='Weighted_Count')

# Create an interactive horizontal bar plot using Plotly Express
fig = px.bar(supplier_region_weighted_counts, x='Weighted_Count', y='region_name', color='supplier',
             labels={'Weighted_Count': 'Weighted Occurrences'},
             title='Distribution of Suppliers by Region (Weighted by dailytotal)',
             orientation='h')  # Set orientation='h' for horizontal

# Show the plot
fig.show()

import pandas as pd
import plotly.express as px

# Assuming you have a DataFrame 'df' with columns like 'administration_date', 'supplier', 'dailytotal', etc.
# df = ...

# Create an interactive line plot using Plotly Express
fig = px.line(df, x='administration_date', y='dailytotal', color='supplier',
              labels={'dailytotal': 'Daily Vaccination Count'},
              title='Vaccination Counts Over Time by Supplier')

# Show the plot
fig.show()

import pandas as pd
import plotly.express as px

# Assuming you have a DataFrame 'df' with columns like 'first_dose', 'second_dose', etc.
# df = ...

# Sum the doses for each type
dose_sums = df[['first_dose', 'second_dose', 'previous_infection', 'additional_booster_dose', 'second_booster', 'db3']].sum()

# Create a DataFrame for plotting
df_plot = pd.DataFrame({'Dose Type': dose_sums.index, 'Count': dose_sums.values})

# Create an interactive bar plot using Plotly Express
fig = px.bar(df_plot, x='Dose Type', y='Count',
             labels={'Count': 'Total Number of Doses'},
             title='Total Number of Doses by Dose Type')

# Show the plot
fig.show()

import numpy as np
import pandas as pd

# Load the dataset into a Pandas DataFrame
file_path = 'ita_reg_ann_data.csv'
df = pd.read_csv(file_path)

# Print the columns
print("Columns in the dataset:")
print(df.columns)

df.head()

import pandas as pd

# Load the datasets
italian_vaccination = pd.read_csv('italian_vaccination.csv')
ita_reg_ann_data = pd.read_csv('ita_reg_ann_data.csv')

# Extract relevant columns from ita_reg_ann_data
columns_to_add = ['cod_reg', 'den_reg', 'pop_resid', 'gdp_tot', 'dens_ab']
data_to_add = ita_reg_ann_data[columns_to_add]

# Merge datasets based on 'cod_reg' and 'den_reg'
merged_data = pd.merge(italian_vaccination, data_to_add, how='left', left_on=['ISTAT_regional_code', 'region_name'],
                      right_on=['cod_reg', 'den_reg'])

# Drop duplicate columns and unnecessary ones
columns_to_drop = ['cod_reg', 'den_reg']
merged_data.drop(columns=columns_to_drop, inplace=True)

# Save the merged dataset
merged_data.to_csv('italian_vaccination_mergedPopGDP.csv', index=False)

merged_data.tail()

import numpy as np
import pandas as pd

# Load the dataset into a Pandas DataFrame
file_path = '/content/ita_reg_mens_clima.csv'
df = pd.read_csv(file_path)

# Print the columns
print("Columns in the dataset:")
print(df.columns)

df.head()

import numpy as np
import pandas as pd

# Load the dataset into a Pandas DataFrame
file_path = '/content/italian_vaccination_mergedPopGDP.csv'
df = pd.read_csv(file_path)
df['dailytotal'] = df['males'] + df['females']
df.to_csv('italian_vaccination_mergedPopGDP.csv', index=False)

# Print the columns
print("Columns in the dataset:")
print(df.columns)

import pandas as pd
import plotly.express as px

# Assuming you have a DataFrame 'df' with columns 'region_name' and 'pop_resid'
# df = ...

# Extract unique pop_resid values for each region_name
unique_pop_resid = df.groupby('region_name')['pop_resid'].first().reset_index()

# Create an interactive horizontal bar plot using Plotly Express
fig = px.bar(unique_pop_resid, x='pop_resid', y='region_name',
             labels={'pop_resid': 'Population Residual'},
             title='Population Residual for Each Region',
             orientation='h')  # Set orientation='h' for horizontal

# Show the plot
fig.show()

import pandas as pd
import plotly.express as px

# Assuming you have a DataFrame 'df' with columns 'region_name' and 'dailytotal'
# df = ...

# Group by 'region_name' and sum 'dailytotal'
region_dailytotal = df.groupby('region_name')['dailytotal'].sum().reset_index()

# Create an interactive horizontal bar plot using Plotly Express
fig = px.bar(region_dailytotal, x='dailytotal', y='region_name',
             labels={'dailytotal': 'Total Daily Vaccinations'},
             title='Total Daily Vaccinations for Each Region',
             orientation='h')  # Set orientation='h' for horizontal

# Show the plot
fig.show()

import pandas as pd
import plotly.express as px

# Assuming you have a DataFrame 'df' with columns 'region_name', 'dailytotal', and 'pop_resid'
# df = ...

# Group by 'region_name' and sum 'dailytotal', and extract unique 'pop_resid' values
region_stats = df.groupby('region_name').agg({'dailytotal': 'sum', 'pop_resid': 'first'}).reset_index()

# Melt the DataFrame to create a long-format for Plotly Express
melted_df = pd.melt(region_stats, id_vars='region_name', value_vars=['dailytotal', 'pop_resid'],
                    var_name='Metric', value_name='Value')

# Create a grouped bar plot
fig = px.bar(melted_df, x='Value', y='region_name', color='Metric',
             labels={'Value': 'Value', 'Metric': 'Metric'},
             title='Comparison of Population and Vaccination Doses for Each Region',
             orientation='h', width=800, height=400)

# Show the plot
fig.show()

import pandas as pd
import plotly.express as px

# Assuming you have a DataFrame 'df' with columns 'region_name', 'dailytotal', and 'pop_resid'
# df = ...

# Group by 'region_name' and sum 'dailytotal', and extract unique 'pop_resid' values
region_stats = df.groupby('region_name').agg({'dailytotal': 'sum', 'pop_resid': 'first'}).reset_index()

# Create a scatter plot
fig = px.scatter(region_stats, x='dailytotal', y='pop_resid', color='region_name',
                 labels={'dailytotal': 'Daily Total', 'pop_resid': 'Population Residual'},
                 title='Comparison of Daily Total with Population Residual for Each Region',
                 width=800, height=400)

# Show the plot
fig.show()

import pandas as pd
import plotly.express as px

# Assuming you have a DataFrame 'df' with columns 'region_name', 'gdp_tot', and 'dailytotal'
# df = ...

# Group by 'region_name' and get the first value for 'gdp_tot' and sum 'dailytotal'
region_stats = df.groupby('region_name').agg({'gdp_tot': 'first', 'dailytotal': 'sum'}).reset_index()

# Replace NaN values in 'gdp_tot' with a default size (e.g., 100)
default_size = 100
region_stats['gdp_tot'].fillna(default_size, inplace=True)

# Convert 'gdp_tot' to million euros
region_stats['gdp_tot_million'] = region_stats['gdp_tot'] * 1_000_000

# Create a scatter plot
fig = px.scatter(region_stats, x='dailytotal', y='gdp_tot_million', color='region_name',
                 size='gdp_tot',  # Use 'gdp_tot' for the size of the markers
                 labels={'dailytotal': 'Daily Total', 'gdp_tot_million': 'GDP Total ', 'region_name': 'Region'},
                 title='Comparison of Daily Total with GDP Total for Each Region',
                 width=800, height=400)

# Show the plot
fig.show()

import pandas as pd
import plotly.express as px

# Assuming you have a DataFrame 'df' with columns 'region_name', 'previous_infection'
# df = ...

# Sum the 'previous_infection' doses for each region
df_sum_previous_infection = df.groupby('region_name')['previous_infection'].sum().reset_index()

# Create an interactive horizontal bar plot for 'previous_infection' doses using Plotly Express
fig = px.bar(df_sum_previous_infection, x='previous_infection', y='region_name',
             labels={'previous_infection': 'Count', 'region_name': 'Region'},
             title='Distribution of Previous Infection Doses by Region',
             orientation='h')

# Show the plot
fig.show()

import pandas as pd
import plotly.express as px

# Assuming you have a DataFrame 'df' with columns 'region_name', 'previous_infection'
# df = ...

# Sum the 'previous_infection' doses for each region
df_sum_previous_infection = df.groupby('region_name')['previous_infection'].sum().reset_index()

# Create a bar plot for 'previous_infection' doses using Plotly Express
fig = px.bar(df_sum_previous_infection, x='region_name', y='previous_infection',
             labels={'previous_infection': 'Count', 'region_name': 'Region'},
             title='Distribution of Previous Infection Doses by Region')

# Show the plot
fig.show()

import pandas as pd
import plotly.express as px

# Assuming you have a DataFrame 'df' with columns 'region_name', 'previous_infection', 'gdp_tot', and 'pop_resid'
# df = ...

# Multiply 'gdp_tot' by 1,000,000 to convert to million euros
df['gdp_tot'] *= 1000000

# Group by 'region_name' and sum 'previous_infection'
region_stats = df.groupby('region_name').agg({'previous_infection': 'sum', 'gdp_tot': 'first', 'pop_resid': 'first'}).reset_index()

# Fill NaN values in 'pop_resid' with 0
region_stats['pop_resid'].fillna(0, inplace=True)

# Create a scatter plot
fig = px.scatter(region_stats, x='previous_infection', y='gdp_tot', size='pop_resid', color='region_name',
                 labels={'previous_infection': 'Sum of Previous Infection Count', 'gdp_tot': 'GDP Total', 'pop_resid': 'Population'},
                 title='Comparison of Previous Infection with GDP and Population for Each Region',
                 width=800, height=400)

# Show the plot
fig.show()

import pandas as pd
import plotly.express as px

# Assuming you have a DataFrame 'df' with columns 'region_name', 'age_range', and 'dailytotal'
# df = ...

# Group by 'region_name' and 'age_range', summing 'dailytotal'
region_age_distribution = df.groupby(['region_name', 'age_range'])['dailytotal'].sum().reset_index()

# Create a bar plot
fig = px.bar(region_age_distribution, x='region_name', y='dailytotal', color='age_range',
             labels={'dailytotal': 'Count', 'region_name': 'Region', 'age_range': 'Age Range'},
             title='Distribution of Age Range by Region',
             width=1000, height=700)

# Show the plot
fig.show()

import pandas as pd
import plotly.express as px

# Assuming you have a DataFrame 'df' with columns 'age_range', 'first_dose', 'second_dose', 'previous_infection', 'additional_booster_dose', 'second_booster', 'db3'
# df = ...

# Sum the doses for each age range
df_summed = df.groupby('age_range').agg({
    'first_dose': 'sum',
    'second_dose': 'sum',
    'previous_infection': 'sum',
    'additional_booster_dose': 'sum',
    'second_booster': 'sum',
    'db3': 'sum'
}).reset_index()

# Melt the DataFrame to create a long-format for Plotly Express
df_melted = pd.melt(df_summed, id_vars=['age_range'], value_vars=['first_dose', 'second_dose', 'previous_infection', 'additional_booster_dose', 'second_booster', 'db3'],
                    var_name='Dose Type', value_name='Count')

# Create a bar plot
fig = px.bar(df_melted, x='Dose Type', y='Count', color='age_range',
             labels={'Count': 'Count', 'age_range': 'Age Range', 'Dose Type': 'Dose Type'},
             title='Distribution of Doses by Age Range',
             width=1000, height=600)

# Show the plot
fig.show()

import pandas as pd
import plotly.express as px

# Assuming you have a DataFrame 'df' with columns 'age_range', 'supplier', and 'dailytotal'
# df = ...

# Group by 'age_range', 'supplier', and sum 'dailytotal'
df_summed = df.groupby(['age_range', 'supplier']).agg({'dailytotal': 'sum'}).reset_index()

# Create a bar plot
fig = px.bar(df_summed, x='supplier', y='dailytotal', color='age_range',
             labels={'dailytotal': 'Total Count', 'age_range': 'Age Range', 'supplier': 'Supplier'},
             title='Distribution of Counts by Age Range and Supplier',
             width=1000, height=600)

# Show the plot
fig.show()

import pandas as pd
import plotly.express as px

# Assuming you have a DataFrame 'df' with columns 'age_range', 'first_dose', 'second_dose', 'previous_infection', 'additional_booster_dose', 'second_booster', 'db3', 'supplier'
# df = ...

# Sum the doses for each age range and supplier
df_summed = df.groupby(['age_range', 'supplier']).agg({
    'first_dose': 'sum',
    'second_dose': 'sum',
    'previous_infection': 'sum',
    'additional_booster_dose': 'sum',
    'second_booster': 'sum',
    'db3': 'sum'
}).reset_index()

# Melt the DataFrame to create a long-format for Plotly Express
df_melted = pd.melt(df_summed, id_vars=['age_range', 'supplier'], value_vars=['first_dose', 'second_dose', 'previous_infection', 'additional_booster_dose', 'second_booster', 'db3'],
                    var_name='Dose Type', value_name='Count')

# Create a bar plot
fig = px.bar(df_melted, x='Dose Type', y='Count', color='age_range', facet_col='supplier',
             labels={'Count': 'Count', 'age_range': 'Age Range', 'Dose Type': 'Dose Type'},
             title='Distribution of Doses by Age Range and Supplier',
             width=1200, height=800)

# Show the plot
fig.show()

import pandas as pd
from statsmodels.tsa.stattools import adfuller
import matplotlib.pyplot as plt

# Load the dataset
df = pd.read_csv('/content/italian_vaccination_mergedPopGDP.csv')

# Convert 'administration_date' to datetime
df['administration_date'] = pd.to_datetime(df['administration_date'])

# Group by dates and sum the 'dailytotal'
dailytotal_series = df.groupby('administration_date')['dailytotal'].sum()

# Plot the original time series
plt.figure(figsize=(12, 6))
plt.plot(dailytotal_series, label='Original Series')
plt.title('Original Time Series')
plt.xlabel('Date')
plt.ylabel('Daily Total Vaccinations')
plt.legend()
plt.show()

# Perform Augmented Dickey-Fuller (ADF) test for stationary testing on the original series
result = adfuller(dailytotal_series, autolag='AIC')
print('ADF Statistic (original series):', result[0])
print('p-value (original series):', result[1])
print('Critical Values (original series):', result[4])

# If needed, apply differencing to achieve stationarity (e.g., first-order differencing)
dailytotal_diff = dailytotal_series.diff().dropna()

# Plot the differenced series
plt.figure(figsize=(12, 6))
plt.plot(dailytotal_diff, label='Differenced Series', color='orange')
plt.title('Differenced Time Series')
plt.xlabel('Date')
plt.ylabel('Differenced Daily Total Vaccinations')
plt.legend()
plt.show()

# Perform ADF test on the differenced series
result_diff = adfuller(dailytotal_diff, autolag='AIC')
print('\nADF Statistic after differencing:', result_diff[0])
print('p-value after differencing:', result_diff[1])
print('Critical Values after differencing:', result_diff[4])

# Print whether the series is stationary based on p-value
if result[1] <= 0.05:
    print('\nThe original series is likely stationary.')
else:
    print('\nThe original series is likely non-stationary.')

if result_diff[1] <= 0.05:
    print('The differenced series is likely stationary.')
else:
    print('The differenced series is likely non-stationary.')

import pandas as pd
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.tsa.stattools import adfuller
import matplotlib.pyplot as plt

# Load the dataset
df = pd.read_csv('/content/italian_vaccination_mergedPopGDP.csv')

# Convert 'administration_date' to datetime
df['administration_date'] = pd.to_datetime(df['administration_date'])

# Group by dates and sum the 'dailytotal'
dailytotal_series = df.groupby('administration_date')['dailytotal'].sum()

# Seasonal Decomposition for the original series
stl_result_original = seasonal_decompose(dailytotal_series, model='additive', period=365)

# Plot the original time series and its components
plt.figure(figsize=(12, 8))
plt.subplot(4, 1, 1)
plt.plot(dailytotal_series, label='Original Series')
plt.title('Original Time Series')

plt.subplot(4, 1, 2)
plt.plot(stl_result_original.trend, label='Trend')
plt.title('Trend Component')

plt.subplot(4, 1, 3)
plt.plot(stl_result_original.seasonal, label='Seasonal')
plt.title('Seasonal Component')

plt.subplot(4, 1, 4)
plt.plot(stl_result_original.resid, label='Residuals')
plt.title('Residuals')
plt.xlabel('Date')

plt.tight_layout()
plt.show()

# Augmented Dickey-Fuller (ADF) test for stationary testing on the residuals
result_residual_original = adfuller(stl_result_original.resid.dropna(), autolag='AIC')
print('\nADF Statistic for residuals (original series):', result_residual_original[0])
print('p-value for residuals (original series):', result_residual_original[1])
print('Critical Values for residuals (original series):', result_residual_original[4])

# Check if the original series has seasonality
if result_residual_original[1] <= 0.05:
    print('\nThe original series likely has seasonality.')
else:
    print('\nThe original series likely does not have seasonality.')

# If needed, apply differencing to achieve stationarity (e.g., first-order differencing)
dailytotal_diff = dailytotal_series.diff().dropna()

# Seasonal Decomposition for the differenced series
stl_result_diff = seasonal_decompose(dailytotal_diff, model='additive', period=365)

# Plot the differenced series and its components
plt.figure(figsize=(12, 8))
plt.subplot(4, 1, 1)
plt.plot(dailytotal_diff, label='Differenced Series', color='orange')
plt.title('Differenced Time Series')

plt.subplot(4, 1, 2)
plt.plot(stl_result_diff.trend, label='Trend')
plt.title('Trend Component')

plt.subplot(4, 1, 3)
plt.plot(stl_result_diff.seasonal, label='Seasonal')
plt.title('Seasonal Component')

plt.subplot(4, 1, 4)
plt.plot(stl_result_diff.resid, label='Residuals')
plt.title('Residuals')
plt.xlabel('Date')

plt.tight_layout()
plt.show()

# Augmented Dickey-Fuller (ADF) test for stationary testing on the residuals after differencing
result_residual_diff = adfuller(stl_result_diff.resid.dropna(), autolag='AIC')
print('\nADF Statistic for residuals after differencing:', result_residual_diff[0])
print('p-value for residuals after differencing:', result_residual_diff[1])
print('Critical Values for residuals after differencing:', result_residual_diff[4])

# Check if the differenced series has seasonality
if result_residual_diff[1] <= 0.05:
    print('The differenced series likely has seasonality.')
else:
    print('The differenced series likely does not have seasonality.')

import pandas as pd
from statsmodels.tsa.seasonal import seasonal_decompose
import matplotlib.pyplot as plt

# Load the dataset
df = pd.read_csv('/content/italian_vaccination_mergedPopGDP.csv')

# Convert 'administration_date' to datetime
df['administration_date'] = pd.to_datetime(df['administration_date'])

# Group by dates and sum the 'dailytotal'
dailytotal_series = df.groupby('administration_date')['dailytotal'].sum()

# Seasonal Decomposition for the original series
stl_result_original = seasonal_decompose(dailytotal_series, model='additive', period=365)

# Plot the original time series and its components
plt.figure(figsize=(12, 8))
plt.subplot(4, 1, 1)
plt.plot(dailytotal_series, label='Original Series')
plt.title('Original Time Series')

plt.subplot(4, 1, 2)
plt.plot(stl_result_original.trend, label='Trend')
plt.title('Trend Component')

plt.subplot(4, 1, 3)
plt.plot(stl_result_original.seasonal, label='Seasonal')
plt.title('Seasonal Component')

plt.subplot(4, 1, 4)
plt.plot(stl_result_original.resid, label='Residuals')
plt.title('Residuals')
plt.xlabel('Date')

plt.tight_layout()
plt.show()

# Check if the original series has seasonality
if stl_result_original.seasonal.notna().any():
    print('\nThe original series likely has seasonality.')
else:
    print('\nThe original series likely does not have seasonality.')

"""In above code Snippet, seasonality is checked based on the presence of values in the `seasonal` component obtained from the seasonal decomposition. Specifically, the code uses the following logic:

```python
# Check if the original series has seasonality
if stl_result_original.seasonal.notna().any():
    print('\nThe original series likely has seasonality.')
else:
    print('\nThe original series likely does not have seasonality.')
```

Here's an explanation of the logic:

1. The `seasonal_decompose` function from `statsmodels` is applied to the original time series (`dailytotal_series`). The decomposition results in components such as trend, seasonal, and residuals.

2. The `seasonal` component of the decomposition result is accessed using `stl_result_original.seasonal`.

3. The `.notna().any()` method chain is used to check if there is at least one non-null value in the seasonal component. If there is at least one non-null value, it indicates the presence of seasonality.

4. If the condition is met, the code prints that "The original series likely has seasonality." Otherwise, it prints that "The original series likely does not have seasonality."

This approach is a simple way to infer seasonality based on the existence of values in the seasonal component. If there are noticeable patterns or fluctuations in the seasonal component, it suggests the presence of seasonality in the original time series. However, it's important to note that this is a heuristic method and might not be as robust as more advanced seasonality detection techniques.
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.statespace.sarimax import SARIMAX
from sklearn.metrics import mean_squared_error
from math import sqrt

# Load the dataset
df = pd.read_csv('/content/italian_vaccination_mergedPopGDP.csv')
df['administration_date'] = pd.to_datetime(df['administration_date'])

# Group by dates and sum the 'dailytotal' column
dailytotal_series = df.groupby('administration_date')['dailytotal'].sum()

# Apply differencing to achieve stationarity (e.g., first-order differencing)
target_diff = dailytotal_series.diff().dropna()

# Split the dataset into training and testing sets
train_size = int(len(target_diff) * 0.8)
train, test = target_diff[0:train_size], target_diff[train_size:]

# Define SARIMA model parameters (you may need to tune these)
order = (1, 1, 1)  # ARIMA order
seasonal_order = (0, 1, 1, 7)  # Seasonal order with a 7-day seasonality

# Fit SARIMA model
sarima_model = SARIMAX(train, order=order, seasonal_order=seasonal_order)
sarima_fit = sarima_model.fit(disp=False)

# Forecasting with SARIMA
sarima_forecast = sarima_fit.get_forecast(steps=len(test))
sarima_mean = sarima_forecast.predicted_mean
sarima_conf_int = sarima_forecast.conf_int()

# Invert differencing to obtain the forecast in the original scale
sarima_forecast_inverted = dailytotal_series[train_size - 1] + sarima_mean.cumsum()
# Evaluate SARIMA
rmse_sarima = sqrt(mean_squared_error(dailytotal_series[train_size:train_size+len(test)], sarima_forecast_inverted))

# Calculate train accuracy
train_pred = sarima_fit.get_prediction(start=0, end=train_size - 1)
train_pred_mean = train_pred.predicted_mean
train_accuracy = sqrt(mean_squared_error(target_diff[:train_size], train_pred_mean))

# Print RMSE for SARIMA and train accuracy
print('RMSE for SARIMA:', rmse_sarima)
print('Train Accuracy:', train_accuracy)

# Print train size
print('Train Size:', train_size)

sarima_forecast_inverted_adjusted = np.maximum(sarima_forecast_inverted, 0)

# Plot the adjusted forecast
plt.figure(figsize=(12, 6))
plt.plot(dailytotal_series.index[train_size:], dailytotal_series[train_size:], label='Original Series')
plt.plot(test.index, sarima_forecast_inverted_adjusted, label='SARIMA Forecast (Adjusted)')
plt.title('SARIMA Forecasting (Adjusted) Diff Version')
plt.xlabel('Date')
plt.ylabel('dailytotal')
plt.legend()
plt.show()

"""**Time Series Forcasting**"""

import pandas as pd
from statsmodels.tsa.seasonal import STL
import matplotlib.pyplot as plt

def perform_stl_forecast(time_series, period, forecast_steps):
    """
    Perform STL decomposition and make forecasts.

    Parameters:
    - time_series: pandas Series, the input time series
    - period: int, the seasonal period of the time series
    - forecast_steps: int, the number of steps to forecast into the future

    Returns:
    - forecast: pandas Series, the forecasted values
    """

    # Perform STL decomposition
    stl = STL(time_series, period=period)
    result = stl.fit()

    # Forecast using the seasonal component
    seasonal_forecast = result.trend + result.resid

    # Make forecasts into the future
    forecast_index = pd.date_range(time_series.index[-1], periods=forecast_steps + 1, freq='D')[1:]
    forecast = pd.Series(index=forecast_index)

    for i in range(forecast_steps):
        # Extend the time series with the seasonal component
        extended_series = pd.concat([time_series, seasonal_forecast])

        # Perform STL decomposition on the extended series
        stl_extended = STL(extended_series, period=period)
        result_extended = stl_extended.fit()

        # Extract the forecasted value
        forecast[i] = result_extended.trend.iloc[-1] + result_extended.resid.iloc[-1]

        # Update the time series for the next iteration
        time_series = time_series.append(pd.Series(forecast[i], index=[forecast_index[i]]))
        seasonal_forecast = result_extended.trend + result_extended.resid

    return forecast

# Load the dataset
df = pd.read_csv('/content/italian_vaccination_mergedPopGDP.csv')
df['administration_date'] = pd.to_datetime(df['administration_date'])
df.set_index('administration_date', inplace=True)

# Extract the relevant time series (e.g., 'dailytotal')
your_time_series = df['dailytotal']

# Set the seasonal period based on your data's seasonality
seasonal_period = 7  # adjust based on your data
forecast_steps = 30  # number of days to forecast into the future

# Perform STL forecast
forecast_result = perform_stl_forecast(your_time_series, seasonal_period, forecast_steps)

# Plot the results
plt.figure(figsize=(12, 6))
plt.plot(your_time_series, label='Original Series')
plt.plot(forecast_result, label='STL Forecast')
plt.title('STL Forecasting')
plt.xlabel('Date')
plt.ylabel('Value')
plt.legend()
plt.show()

import warnings
import pandas as pd
from statsmodels.tsa.seasonal import STL
import matplotlib.pyplot as plt
import numpy as np
from sklearn.metrics import mean_squared_error, accuracy_score

warnings.simplefilter(action='ignore', category=FutureWarning
                      )
def perform_stl_forecast(time_series, period, forecast_steps):
    """
    Perform STL decomposition and make forecasts.

    Parameters:
    - time_series: pandas Series, the input time series
    - period: int, the seasonal period of the time series
    - forecast_steps: int, the number of steps to forecast into the future

    Returns:
    - forecast: pandas Series, the forecasted values
    """

    # Perform STL decomposition
    stl = STL(time_series, period=period)
    result = stl.fit()

    # Forecast using the seasonal component
    seasonal_forecast = result.trend + result.resid

    # Make forecasts into the future
    forecast_index = pd.date_range(time_series.index[-1], periods=forecast_steps + 1, freq='D')[1:]
    forecast = pd.Series(index=forecast_index)

    for i in range(forecast_steps):
        # Extend the time series with the seasonal component
        extended_series = pd.concat([time_series, seasonal_forecast])

        # Perform STL decomposition on the extended series
        stl_extended = STL(extended_series, period=period)
        result_extended = stl_extended.fit()

        # Extract the forecasted value
        forecast[i] = result_extended.trend.iloc[-1] + result_extended.resid.iloc[-1]

        # Update the time series for the next iteration
        time_series = time_series.append(pd.Series(forecast[i], index=[forecast_index[i]]))
        seasonal_forecast = result_extended.trend + result_extended.resid

    return forecast

# Load the dataset
df = pd.read_csv('/content/italian_vaccination_mergedPopGDP.csv')
df['administration_date'] = pd.to_datetime(df['administration_date'])
df.set_index('administration_date', inplace=True)

# Extract the relevant time series (e.g., 'dailytotal')
your_time_series = df['dailytotal']

# Set the seasonal period based on your data's seasonality
seasonal_period = 7  # adjust based on your data
forecast_steps = 90  # number of days to forecast into the future

# Perform STL forecast
forecast_result = perform_stl_forecast(your_time_series, seasonal_period, forecast_steps)

# Calculate RMSE
rmse = np.sqrt(mean_squared_error(your_time_series[-forecast_steps:], forecast_result))
print('RMSE for STL Forecast:', rmse)

# Calculate Accuracy (for illustration purposes, replace 'threshold' with a suitable value)
threshold = 0.1  # replace with an appropriate threshold for your problem
accuracy = accuracy_score((your_time_series[-forecast_steps:] - forecast_result).abs() < threshold, [True] * forecast_steps)
print('Accuracy for STL Forecast:', accuracy)

# Plot the results
plt.figure(figsize=(12, 6))
plt.plot(your_time_series, label='Original Series')
plt.plot(forecast_result, label='STL Forecast')
plt.title('STL Forecasting')
plt.xlabel('Date')
plt.ylabel('Value')
plt.legend()
plt.show()

import numpy as np
from sklearn.metrics import mean_squared_error

# Assuming 'your_time_series' is your original time series
# and 'forecast_result' is the forecasted values obtained from STL

# Calculate RMSE
rmse = np.sqrt(mean_squared_error(your_time_series[-forecast_steps:], forecast_result))
print('RMSE for STL Forecast:', rmse)

# MIN MAX SCALING
import pandas as pd
from sklearn.preprocessing import MinMaxScaler
import matplotlib.pyplot as plt

# Load the dataset
df = pd.read_csv('/content/italian_vaccination_mergedPopGDP.csv')
df['administration_date'] = pd.to_datetime(df['administration_date'])
df.set_index('administration_date', inplace=True)

# Extract the relevant time series (e.g., 'dailytotal')
your_time_series = df['dailytotal']

# Reshape the time series for Min-Max scaling
data_to_scale = your_time_series.values.reshape(-1, 1)

# Perform Min-Max scaling
scaler = MinMaxScaler()
scaled_data = scaler.fit_transform(data_to_scale)

# Inverse transform to get the original scale (if needed)
# original_scale_data = scaler.inverse_transform(scaled_data)

# Plot the results
plt.figure(figsize=(12, 6))

plt.subplot(2, 1, 1)
plt.plot(your_time_series, label='Original Series')
plt.title('Original Time Series')
plt.xlabel('Date')
plt.ylabel('Value')
plt.legend()

plt.subplot(2, 1, 2)
plt.plot(your_time_series.index, scaled_data, label='Scaled Series', color='orange')
plt.title('Min-Max Scaled Time Series')
plt.xlabel('Date')
plt.ylabel('Scaled Value')
plt.legend()

plt.tight_layout()
plt.show()

#STL

import pandas as pd
from statsmodels.tsa.seasonal import STL
from sklearn.preprocessing import MinMaxScaler
import numpy as np
import matplotlib.pyplot as plt

def perform_stl_forecast(time_series, period, forecast_steps):
    stl = STL(time_series, period=period)
    result = stl.fit()

    seasonal_forecast = result.trend + result.resid

    forecast_index = pd.date_range(time_series.index[-1], periods=forecast_steps + 1, freq='M')[1:]
    forecast = pd.Series(index=forecast_index)

    for i in range(forecast_steps):
        extended_series = pd.concat([time_series, seasonal_forecast])

        stl_extended = STL(extended_series, period=period)
        result_extended = stl_extended.fit()

        forecast[i] = result_extended.trend.iloc[-1] + result_extended.resid.iloc[-1]

        time_series = time_series.append(pd.Series(forecast[i], index=[forecast_index[i]]))
        seasonal_forecast = result_extended.trend + result_extended.resid

    return forecast

# Load the dataset
df = pd.read_csv('/content/italian_vaccination_mergedPopGDP.csv')
df['administration_date'] = pd.to_datetime(df['administration_date'])
df.set_index('administration_date', inplace=True)

# Resample to monthly data
monthly_data = df.resample('M').sum()

# Extract the relevant time series (e.g., 'dailytotal')
your_time_series = monthly_data['dailytotal']

# Normalize the data
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(your_time_series.values.reshape(-1, 1))

# Set the seasonal period based on your data's seasonality
seasonal_period = 12  # Monthly seasonality
forecast_steps = 12  # number of months to forecast into the future

# Convert the scaled_data to a pandas Series with a datetime index
scaled_series = pd.Series(scaled_data.flatten(), index=your_time_series.index)

# Perform STL forecast
forecast_result = perform_stl_forecast(scaled_series, seasonal_period, forecast_steps)

# Inverse transform the forecasted data to the original scale
forecast_result_original_scale = scaler.inverse_transform(forecast_result.values.reshape(-1, 1))

# Plot the results
plt.figure(figsize=(12, 6))
plt.plot(your_time_series.index, your_time_series, label='Original Series')
plt.plot(your_time_series.index[-1] + pd.DateOffset(months=1) * np.arange(1, forecast_steps + 1), forecast_result_original_scale, label='STL Forecast')
plt.title('STL Forecasting (Monthly Data)')
plt.xlabel('Date')
plt.ylabel('Value')
plt.legend()
plt.show()

import numpy as np
import pandas as pd

# Specify the path to your CSV file
csv_file_path = '/content/italian_vaccination_mergedPopGDP.csv'

# Read CSV using pandas
df = pd.read_csv(csv_file_path)

import pandas as pd
import numpy as np
import plotly.express as px

# Assuming df is your DataFrame with 'dailytotal' and 'dailytotal_log' columns
# Apply log transform to dailytotal and save it to a new variable
df['dailytotal_log'] = np.log1p(df['dailytotal'])

# Create an interactive line plot
fig = px.line(df, x=df.index, y=['dailytotal', 'dailytotal_log'], labels={'value': 'Daily Total'})
fig.update_layout(title='Actual and Log Transformed Daily Total', xaxis_title='Date', yaxis_title='Value')
fig.show()

import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error
from sklearn.preprocessing import MinMaxScaler
from keras.models import Sequential
from keras.layers import LSTM, Dense, Dropout
import matplotlib.pyplot as plt

# Function to prepare data for LSTM
def prepare_lstm_data(data, time_steps):
    X, y = [], []
    for i in range(len(data) - time_steps):
        X.append(data[i:(i + time_steps), 0])
        y.append(data[i + time_steps, 0])
    return np.array(X), np.array(y)

# Hyperparameters
time_steps = 30  # Adjust based on your data
epochs = 10
batch_size = 32
forecast_steps = 30

# Load the dataset
df = pd.read_csv('italian_vaccination_mergedPopGDP.csv')
df['administration_date'] = pd.to_datetime(df['administration_date'])
df.set_index('administration_date', inplace=True)
your_time_series = df['dailytotal']

# Scale the data
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(your_time_series.values.reshape(-1, 1))

# Prepare data for LSTM
X, y = prepare_lstm_data(scaled_data, time_steps)

# Reshape input data to be 3D [samples, time steps, features]
X = np.reshape(X, (X.shape[0], time_steps, 1))

# Build the LSTM model with regularization
model = Sequential()
model.add(LSTM(50, input_shape=(time_steps, 1), return_sequences=True))
model.add(Dropout(0.2))  # Dropout layer for regularization
model.add(LSTM(50))
model.add(Dropout(0.2))  # Dropout layer for regularization
model.add(Dense(1))
model.compile(optimizer='adam', loss='mean_squared_error')

# Train the model
model.fit(X, y, epochs=epochs, batch_size=batch_size, verbose=2)

# Make predictions on the training set
train_predict = model.predict(X)

# Inverse transform the training predictions
train_predict_original_scale = scaler.inverse_transform(train_predict).flatten()

# Calculate RMSE on the training set
rmse_train = np.sqrt(mean_squared_error(your_time_series.values[time_steps:], train_predict_original_scale))
print(f"Training RMSE: {rmse_train}")

# Test the model on a test set if available
if len(your_time_series) > 2 * forecast_steps:
    # Make predictions for the next 30 days
    forecast_input = scaled_data[-time_steps:].reshape(1, -1, 1)

    forecast_result = []
    for i in range(forecast_steps):
        forecast_value = model.predict(forecast_input)
        forecast_result.append(max(0, forecast_value[0, 0]))  # Set negative predictions to zero
        forecast_input = np.roll(forecast_input, shift=-1, axis=1)
        forecast_input[0, -1, 0] = forecast_result[-1]

    # Inverse transform the forecasted values
    forecast_result_original_scale = scaler.inverse_transform(np.array(forecast_result).reshape(-1, 1)).reshape(-1)

    # Evaluate the model on the training set
    rmse_train = np.sqrt(mean_squared_error(y, model.predict(X)))
    print(f"Training RMSE: {rmse_train}")

    # Test the model on a test set if available
    if len(your_time_series) > 2 * forecast_steps:
        # Split the data into training and test sets
        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

        # Evaluate the model on the test set
        rmse_test = np.sqrt(mean_squared_error(y_test, model.predict(X_test)))
        print(f"Test RMSE: {rmse_test}")
    else:
        print("Not enough data for testing.")

# Print information about the scale of the data compared to RMSE
data_range = np.max(your_time_series) - np.min(your_time_series)
print(f"Data Range: {data_range}")
print(f"RMSE as a Percentage of Data Range: {rmse_train / data_range * 100}")

# Plot both the training predictions and the future forecast
plt.figure(figsize=(12, 8))

# Plot training predictions
plt.subplot(2, 1, 1)
plt.plot(your_time_series.index[time_steps:], your_time_series[time_steps:], label='Actual', marker='o')
plt.plot(your_time_series.index[time_steps:], train_predict_original_scale, label='Train Predicted', marker='o')
plt.title('LSTM Training Prediction')
plt.xlabel('Date')
plt.ylabel('Value')
plt.legend()

# Plot future forecast
plt.subplot(2, 1, 2)
plt.plot(your_time_series.index[-len(your_time_series):], your_time_series[-len(your_time_series):], label='Actual', marker='o')
plt.plot(pd.date_range(your_time_series.index[-1], periods=forecast_steps + 1, freq='D')[1:], forecast_result_original_scale, label='Predicted', marker='o')
plt.title('LSTM Future Forecast')
plt.xlabel('Date')
plt.ylabel('Value')
plt.legend()

plt.tight_layout()
plt.show()

"""The model performance looks promising. Here's an interpretation of the evaluation metrics:

- **Training RMSE:** This metric measures the root mean squared error on the training set. In this case, a lower value (0.0187) indicates that the model is able to capture the patterns in the training data relatively well.

- **Test RMSE:** The root mean squared error on the test set (0.00317) is also low, suggesting that the model generalizes well to new, unseen data. A low test RMSE is indicative of good predictive performance.

- **Data Range:** The range of the original data is 44211. This provides context for interpreting the RMSE values. The smaller the RMSE compared to the data range, the better the model's performance.

- **RMSE as a Percentage of Data Range:** This is a normalized metric that indicates the relative magnitude of the RMSE compared to the data range. A small percentage (4.24e-05) suggests that the model's error is a very small fraction of the overall data range.

Overall, the results suggest that the LSTM model is performing well on both the training and test sets.
"""

df.tail()